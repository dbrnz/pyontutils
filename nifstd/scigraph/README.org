#+TITLE: Using SciGraph
#+OPTIONS: num:nil
#+STARTUP: showall

* Introduction
Over the past 4 years we have employed multiple different workflows
for deploying a variety of ontologies to production SciGraph instances.
This readme consolidates everything that we have learned into what we
considered to be one reasonably optimal workflow that avoids most of the
hidden pitfalls.
* Using this file
You can either [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]]
this file in emacs using =C-c C-v t= or you can tangle
the whole file from the command line using with the following.
#+begin_src bash :var THIS_FILE=(buffer-file-name) :results none
: ${THIS_FILE:="./README.org"}
emacs --batch \
      --load org \
      --load ob-shell \
      --eval "(org-babel-tangle-file \"${THIS_FILE}\")"
#+end_src
The core functionality is tangled to [[file:./bin/scigraph-functions.sh]].
If you need to use the core functionality becuase one of the =run-*= commands
does not meet your needs, just make sure to source that file so your will have
the functions available.
* Setup
:properties:
:visibility: folded
:end:
** Build host
*** Gentoo
:PROPERTIES:
:CUSTOM_ID: Setup:Build host:Gentoo
:END:
#+begin_src bash
layman -a tgbugs-overlay

emerge \
pyontutils \
rpmdevtools \
scigraph-bin
#+end_src
*** Ubuntu
:PROPERTIES:
:CUSTOM_ID: Setup:Build host:Ubuntu
:END:
#+begin_src bash
apt install \
rpm \
python3-dev \
python3-pip

pip install --user \
pyontutils
#+end_src
** Services host
*** Gentoo
:PROPERTIES:
:CUSTOM_ID: Setup:Services host:Gentoo
:END:
#+begin_src bash
layman -a tgbugs-overlay

emerge \
scigraph-bin \
yq
#+end_src
*** AWS Linux 2
:PROPERTIES:
:CREATED:  [2020-01-06 Mon 14:27]
:CUSTOM_ID: Setup:Services host:AWS Linux 2
:END:
Installing the scigraph RPM also handles the creation and configuration
of all relevant variables for operation on RHEL-like systems.
See the [[https://github.com/tgbugs/pyontutils/blob/master/nifstd/scigraph/scigraph.spec][spec file]]
for details.

#+NAME: dir-tramp-sudo
#+header: :noweb yes :results none
#+begin_src emacs-lisp :exports none
(defun :dir-tramp-sudo (ssh-config-hostname)
  (format "/ssh:%s|sudo:%s:" ssh-config-hostname ssh-config-hostname))
#+end_src

#+NAME: aws-block
#+begin_src bash :dir /ssh:hostname|sudo:hostname:
yum install -y \
python3 \
python3-pip

pip3 install \
yq  # yq is usually only needed on config build systems
    # however if something goes wrong and an in place change
    # needs to be made then editing the raw and regenerating
    # is the preferred course of action
#+end_src

# #+CALL: aws-block() :dir /ssh:aws-scigraph|sudo:aws-scigraph: :eval never
# #+CALL: aws-block() :dir (:dir-tramp-sudo "aws-scigraph") :eval never
* User setup
:properties:
:visibility: folded
:end:
This setup should be completed on the build host or on the ops host
that talks to both the build host and the services host. Currently the
build host and ops host are conflated.
** ssh config
Set =ip-aws-scigraph= here
#+name: ip-aws-scigraph
: 127.0.0.1

Set =ip-aws-scigraph-data= here
#+name: ip-aws-scigraph-data
: 127.0.0.1

Set =path-target-identity-file= here
#+name: path-target-identity-file
: /dev/null

# NOTE: it is good practice to require any computer wanting to connect
# to have two keys, one for the bastion and one for the target host
# that way if the bastion is compromised the keys to get to the protected
# hosts cannot be obtained from that machine alone
# if a user's machine is compromised then access to the bastion can be
# shut down for just that user and if the jump key is shared, then
# it can be rotated under less time pressure

Set =path-jump-identity-file= here
#+name: path-jump-identity-file
: /dev/null

Set =jump-host= aka bastion server name here
#+name: jump-host
: localhost

Set =ip-jump-host= here
#+name: ip-jump-host
: 127.0.0.1

Set =user-jump-host= here
#+name: user-jump-host
: nobody

Tangle this block after setting the requisite values above.
#+begin_src conf :noweb yes :tangle ~/.ssh/config.scigraph.example
# enable connection multiplexing for all hosts
Host *
ServerAliveInterval 60
ControlMaster auto
ControlPath ~/.ssh_tmp/master-%r@%h:%p

# jump host should be whitelisted in the target firewall
Host <<jump-host()>>
HostName <<ip-jump-host()>>
User <<user-jump-host()>>
IdentityFile <<path-jump-identity-file()>>
PreferredAuthentications publickey

Host aws-scigraph
HostName <<ip-aws-scigraph()>>
User ec2-user
IdentityFile <<path-target-identity-file()>>
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-deploy
HostName <<ip-aws-scigraph()>>
User scigraph
IdentityFile ~/.ssh/id_ed25519.aws.scigraph
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-data
HostName <<ip-aws-scigraph-data()>>
User ec2-user
IdentityFile <<path-target-identity-file()>>
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-data-deploy
HostName <<ip-aws-scigraph-data()>>
User scigraph
IdentityFile ~/.ssh/id_ed25519.aws.scigraph
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p
#+end_src

Create and deploy ssh key for the scigraph deploy user.
#+begin_src bash
ssh-keygen -t ed25519 -N "" -C "${USER}@${HOSTNAME}" -f ~/.ssh/id_ed25519.aws.scigraph
scp ~/.ssh/id_ed25519.aws.scigraph.pub aws-scigraph:${USER}.aws.scigraph.pub
ssh aws-scigraph "sudo cat ${USER}.aws.scigraph.pub >> /var/lib/scigraph/.ssh/authorized_keys && rm ${USER}.aws.scigraph.pub"
#+end_src

Make [[file:${HOME}/.ssh_tmp]] folder to hold multiplexed sockets.
#+begin_src bash
mkdir ~/.ssh_tmp
chmod 0700 ~/.ssh_tmp
#+end_src
* Components
:PROPERTIES:
:header-args: :mkdirp yes
:END:

#+name: path-scigraph-functions
: ~/git/pyontutils/nifstd/scigraph/bin/scigraph-functions.sh

#+name: *source-scigraph-functions
#+begin_src bash :noweb yes
source "$(eval echo <<path-scigraph-functions()>>)"
#+end_src
** Code
:properties:
:visibility: folded
:end:
*** Build
**** RPM
#+begin_src sh
ln -s ~/git/pyontutils/nifstd/scigraph/scigraph.spec ~/files/rpmbuild/SPECS/scigraph.spec

ln -s ~/git/tgbugs-overlay/dev-java/scigraph-bin/files/scigraph.service \
~/files/rpmbuild/SOURCES/scigraph.service

ln -s ~/git/tgbugs-overlay/dev-java/scigraph-bin/files/xvfb.service \
~/files/rpmbuild/SOURCES/xvfb.service

spectool -g -R SPECS/scigraph.spec

rpmbuild -ba --nodeps SPECS/scigraph.spec

scp RPMS/noarch/scigraph-9999-0.noarch.rpm scigraph.scicrunch.io:

rpm -qp --scripts RPMS/noarch/scigraph-9999-0.noarch.rpm
#+end_src

**** ontload nifstd-tools only
Set up a virtualenv if required.
#+begin_src bash
pushd venvs
mkdir scigraph-build
pushd scigraph-build
pipenv --python 3.7
pipenv shell
pip install nifstd-tools
mkdir build
#+end_src

Compile SciGraph.
# ((((
#+name: *vars-compile-scigraph-git
#+begin_src bash :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-zip) local PATH_ZIP="${2}"; shift; shift ;;
    --path-git) local PATH_GIT="${2}"; shift; shift ;;
    --git-ref)  local GIT_REF="${2}"; shift; shift ;;
    *)          POSITIONAL+=("$1"); shift ;;
esac
done

: ${PATH_ZIP:=<<path-build-graph()>>}
: ${PATH_GIT:=<<path-build-graph()>>}
: ${GIT_REF:="master"}

#+end_src
#+name: compile-scigraph-git
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
# NOTE --path-zip and --git-local can be anywhere but both should exist
# they can also be the same folder
function compile-scigraph-git () {
    <<*vars-compile-scigraph-git>>
    ontload scigraph \
    --zip-location ${PATH_ZIP}  ${IFS# build artifacts will be deposited here} \
    --git-local ${PATH_GIT}     ${IFS# remote repos will be cloned here} \
    --scigraph-org SciGraph \
    --scigraph-branch ${GIT_REF}
}
#+end_src
**** docker
https://github.com/SciGraph/SciGraph/tree/master/docker
*** Deploy
**** RPM
source 1: [[file:~/git/pyontutils/nifstd/scigraph/README.md::# RPM builds]]
#+begin_src bash
yum install -y scigraph*.rpm || yum reinstall -y scigraph*.rpm
#+end_src

If you want to have more than one service or have a different name for =services.yaml=
then take a look at =/lib/systemd/system/scigraph.service= and take what you want to
customize and put it in =/etc/systemd/system/scigraph.service.d/scigraph.conf=
(retaining the section hearders).

**** git
**** docker
https://github.com/SciGraph/SciGraph/tree/master/docker
** Graph
*** Build
**** scigraph-load
Set =path-build-graph= here
#+NAME: path-build-graph
: /tmp/scigraph-build

Set =path-graphload-template= here
#+name: path-graphload-template
: ~/git/pyontutils/nifstd/scigraph/graphload-base-template.yaml

#+name: folder-name-graph
: graph

# (((((
#+name: *vars-load-graph
#+begin_src bash :eval never :exports none :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)        local PATH_BUILD="${2}"; shift; shift ;;
    --folder-name-graph) local FOLDER_NAME_GRAPH="${2}"; shift; shift ;;
    --path-graphload)    local PATH_GRAPHLOAD="${2}"; shift; shift ;;
    --path-ontologies)   local PATH_ONTOLOGIES="${2}"; shift; shift ;;
    *)                   POSITIONAL+=("$1"); shift ;;
esac
done

: ${PATH_GRAPHLOAD:=<<path-graphload-template()>>}
: ${PATH_ONTOLOGIES:="./ontologies.yaml"}  # if missing will error
: ${PATH_BUILD:=<<path-build-graph()>>}
: ${FOLDER_NAME_GRAPH:=<<folder-name-graph()>>}
LOAD_GRAPH_PATH="${PATH_BUILD}/${FOLDER_NAME_GRAPH}"
PATH_CONFIG_YAML="${LOAD_GRAPH_PATH}/graphload-$(date +%Y-%m-%d).yaml"
PATH_CONFIG_YAML_RAW="${PATH_CONFIG_YAML}.raw"
STAMPED="${FOLDER_NAME_GRAPH}-graph-$(date +%Y%m%dT%H%M%S)"
FILE_NAME_ZIP="${STAMPED}.zip"
PATH_ZIP="${PATH_BUILD}/${FILE_NAME_ZIP}"
LATEST="${PATH_BUILD}/LATEST"
echo $PATH_GRAPHLOAD $PATH_ONTOLOGIES
echo $LOAD_GRAPH_PATH $FOLDER_NAME_GRAPH $STAMPED $FILE_NAME_ZIP $PATH_ZIP
#+end_src

#+name: load-graph
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
function load-graph () {
    <<*vars-load-graph>>

    if [[ -z "${PATH_ONTOLOGIES}" ]]; then
        echo no ontologies section specified
        exit 1
    fi

    if [[ -d "${LOAD_GRAPH_PATH}" ]]; then
        rm "${LOAD_GRAPH_PATH}" -r
    fi
    mkdir -p "${LOAD_GRAPH_PATH}"
    cat "${PATH_GRAPHLOAD}" "${PATH_ONTOLOGIES}" > "${PATH_CONFIG_YAML_RAW}"
    yq -Y ".graphConfiguration.location = \"${LOAD_GRAPH_PATH}\"" \
        "${PATH_CONFIG_YAML_RAW}"> "${PATH_CONFIG_YAML}"
    scigraph-load -c "${PATH_CONFIG_YAML}"

    pushd "${PATH_BUILD}"
    # mv prevents accidentally deploying the same graph twice
    # but use cp -r for development to avoid continual rebuild
    cp -r ${FOLDER_NAME_GRAPH} ${STAMPED}
    zip -r ${FILE_NAME_ZIP} ${STAMPED}
    unlink "${LATEST}"
    ln -sT "${FILE_NAME_ZIP}" "${LATEST}"
    popd
}
#+end_src
**** ontload
# sigh command line flags inside of flags
# ((((((
#+name: *vars-load-graph-ontload
#+begin_src bash :eval never :exports none :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-graphload)  local PATH_GRAPHLOAD="${2}"; shift; shift ;;
    --path-ontologies) local PATH_ONTOLOGIES="${2}"; shift; shift ;;
    --path-zip)        local PATH_ZIP="${2}"; shift; shift ;;
    --path-git)        local PATH_GIT="${2}"; shift; shift ;;
    --git-ref)         local GIT_REF="${2}"; shift; shift ;;
    *)                 POSITIONAL+=("$1"); shift ;;
esac
done

: ${PATH_GRAPHLOAD:=<<path-graphload-template()>>}
: ${PATH_ONTOLOGIES:="./ontologies.yaml"}
: ${PATH_ZIP:=<<path-build-graph()>>}
: ${PATH_GIT:=<<path-build-graph()>>}
: ${GIT_REF:="master"}
#+end_src

#+name: load-graph-ontload
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
function load-graph-ontload () {
    <<*vars-load-graph-ontload>>
    ontload graph \
    --org SciCrunch  ${IFS# github organization} \
    NIF-Ontology     ${IFS# repo name} \
    NIF              ${IFS# pattern for remote base (e.g. http://) to swap for local file://,
                       NIF automatically expands to http://ontology.neuinfo.org/NIF} \
    --zip-location ${PATH_ZIP}  ${IFS# output folder where the loaded graph zip will be exported} \
    --git-local ${PATH_GIT}     ${IFS# location where git repo will be cloned} \
    --branch ${GIT_REF}             ${IFS# git ref (branch, commit, etc.) from which to build} \
    --graphload-config ${PATH_GRAPHLOAD}       ${IFS# path to graphload-base-template.yaml} \
    --graphload-ontologies ${PATH_ONTOLOGIES}  ${IFS# path to ontologies-graph-name.yaml} \
    ${POSITIONAL}  # pass any other unhandled arguments along
}
#+end_src

If loading fails, then you probably need to patch something in which case you will
need the following commands. See an example setup in [[../nifstd/patches/][nifstd/patches]].
If =--patch= is enabled and the patch config cannot be found you will get an error.

#+name: run-load-graph-ontload-patch
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-ontload-patch
<<*source-scigraph-functions>>
load-graph-ontload \
--patch                      ${IFS# do apply patches} \
--patch-config patches.yaml  ${IFS# path to patche files}
#+end_src
**** ontload nifstd-tools only
When loading using nifstd-tools without a dedicated SciGraph install include the following
to use the version of SciGraph built from git in [[compile-scigraph-git][compile-scigraph-git]].

#+name: run-load-graph-ontload-scigraph-git
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-ontload-scigraph-git
<<*source-scigraph-functions>>
load-graph-ontload \
--build-scigraph \
--scigraph-org SciGraph \
--scigraph-branch master
#+end_src

*** Deploy
Set =path-runtime= here
#+name: path-runtime
: /var/lib/scigraph

Set =folder-name-runtime= here
#+name: folder-name-runtime
: graph

# ((((
#+name: *are-you-sure
#+begin_src bash
read -p "Are you sure you want to deploy? y/N " -n 1 choice
case "${choice}" in
    y|Y) echo ;;
    n|N) echo; echo "Not deploying."; return 1;;
    '?') echo; echo "$(set -o posix; set | grep -v '^_')"; return 1;;
    *)   echo; echo "Not deploying."; return 1;;
esac
echo "Deploying ..."
#+end_src

#+name: localhost-deploy-command
#+begin_src bash :eval never :exports code
cp ${PATH_ZIP} ${PATH_RUNTIME};
pushd ${PATH_RUNTIME};
unzip ${FILE_NAME_ZIP};
unlink ${FOLDER_NAME_GRAPH};
ln -sT ${STAMPED} ${FOLDER_NAME_GRAPH};
popd
#+end_src

# (((((((
#+name: *vars-deploy-graph
#+begin_src bash :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)          local PATH_BUILD="${2}"; shift; shift ;;
    --server)              local SERVER="${2}"; shift; shift ;;
    --svc-user)            local SVC_USER="${2}"; shift; shift ;;
    --path-runtime)        local PATH_RUNTIME="${2}"; shift; shift ;;
    --folder-name-runtime) local FOLDER_NAME_RUNTIME="${2}"; shift; shift ;;
    --path-zip)            local PATH_ZIP="${2}"; shift; shift ;;
    *)                     POSITIONAL+=("$1"); shift ;;
esac
done

: ${PATH_BUILD:=<<path-build-graph()>>}

: ${SERVER:=localhost}
: ${SVC_USER:=scigraph}
: ${PATH_RUNTIME:=<<path-runtime()>>}
: ${FOLDER_NAME_RUNTIME:=<<folder-name-runtime()>>}

LATEST="${PATH_BUILD}/LATEST"
if [ ! -f "${LATEST}" ]; then
    echo $LATEST path does not exist.
    echo Did you actually build the graph?
    echo Not deploying.
    return 1
fi
FILE_NAME_ZIP=$(readlink "${LATEST}")
STAMPED="${FILE_NAME_ZIP//.zip/}"
: ${PATH_ZIP="${PATH_BUILD}/${FILE_NAME_ZIP}"}
if [ ! -f "${PATH_ZIP}" ]; then
    echo $PATH_ZIP path does not exist.
    echo Not deploying.
    return 1
fi
scigraph_host="${SERVER}-deploy"  # by convention
scigraph_host_admin=${SERVER}
echo $FOLDER_NAME_GRAPH $STAMPED $FILE_NAME_ZIP $PATH_ZIP
#+end_src

#+name: deploy-graph
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
function deploy-graph () {
    <<*vars-deploy-graph>>
    echo Will deploy graph to ${SERVER}:${PATH_RUNTIME}
    echo $PATH_ZIP
    <<*are-you-sure>>
    if [ "${SERVER}" = "localhost" ]; then
        CMD="su - ${SVC_USER} -c \"
                <<localhost-deploy-command>>\""
        su - root -c "${CMD}"
    else
        scp "${PATH_ZIP}" "${scigraph_host}:${PATH_RUNTIME}"
        ssh ${scigraph_host} "pushd \"${PATH_RUNTIME}\"; unzip \"${FILE_NAME_ZIP}\""

        ssh ${scigraph_host_admin} "sudo systemctl stop scigraph"

        ssh ${scigraph_host} "unlink \"${PATH_RUNTIME}/${FOLDER_NAME_RUNTIME}\"
                              ln -sT \"${PATH_RUNTIME}/${STAMPED}\" \"${PATH_RUNTIME}/${FOLDER_NAME_RUNTIME}\""

        ssh ${scigraph_host_admin} "sudo systemctl start scigraph"
    fi
}
#+end_src
** Config
*** Build
#+name: path-services
: ~/git/pyontutils/nifstd/scigraph/services-base-template.yaml

#+name: path-curies
: ~/git/pyontutils/nifstd/scigraph/curie_map.yaml
# FIXME rename to curies.yaml and be done with it

#+name: path-build-services
: /tmp/scigraph-build/services

#+name: file-stem-services-output
: services

# ((((((((((
#+name: *vars-build-services
#+begin_src bash :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)            local PATH_BUILD="${2}"; shift; shift ;;
    --path-runtime)          local PATH_RUNTIME="${2}"; shift; shift ;;
    --folder-name-runtime)   local FOLDER_NAME_RUNTIME="${2}"; shift; shift ;;
    --path-cypher-resources) local PATH_CYPHER_RESOURCES="${2}"; shift; shift ;;
    --path-services)         local PATH_SERVICES="${2}"; shift; shift ;;
    --path-curies)           local PATH_CURIES="${2}"; shift; shift ;;
    --file-stem)             local FILE_STEM="${2}"; shift; shift ;;
    --svc-host)              local SVC_HOST="${2}"; shift; shift ;;
    --svc-port)              local SVC_PORT="${2}"; shift; shift ;;
    *) POSITIONAL+=("$1"); shift ;;
esac
done

: ${PATH_BUILD:=<<path-build-services()>>}
: ${PATH_RUNTIME:=<<path-runtime()>>}
: ${FOLDER_NAME_RUNTIME:=<<folder-name-runtime()>>}
: ${PATH_CYPHER_RESOURCES:="./cypher-resources.yaml"}  # will fail on absense
: ${PATH_SERVICES:=<<path-services()>>}
: ${PATH_CURIES:=<<path-curies()>>}
: ${FILE_STEM=<<file-stem-services-output()>>}
: ${SVC_HOST:=localhost}
: ${SVC_PORT:=9000}
URL_BASE="http://${SVC_HOST}:${SVC_PORT}"
URL_VIEW="${URL_BASE}/scigraph/refine/view/{{id}}"
URL_PREVIEW="${URL_BASE}/scigraph/refine/preview/{{id}}"
PATH_SERVICES_GRAPH="${PATH_RUNTIME}/${FOLDER_NAME_GRAPH}"
YAML="${FILE_STEM}.yaml"
DT=$(date +%Y%m%dT%H%M%S)
YAML_RAW="${FILE_STEM}-${DT}.yaml.raw"

PATH_YAML="${PATH_BUILD}/${YAML}"
PATH_YAML_RAW="${PATH_BUILD}/${YAML_RAW}"
#+end_src
# ugh what a mess, the fact that the scigraph yaml parser is a piece of crap doesn't help
# template, raw, and expanded
#+name: build-services
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
function build-services () {
    <<*vars-build-services>>
    # make build location
    mkdir -p "${PATH_BUILD}"

    # TODO allow urls?
    # make raw
    cat "${PATH_SERVICES}" > "${PATH_YAML_RAW}"
    cat "${PATH_CURIES}" | sed 's/^/    /' >> "${PATH_YAML_RAW}"
    cat "${PATH_CYPHER_RESOURCES}" >> "${PATH_YAML_RAW}"

    # make services header
    echo "# ${YAML_RAW}" > "${PATH_YAML}"

    # make services
    yq -Y ".graphConfiguration.location = \"${PATH_SERVICES_GRAPH}\" |
    .serviceMetadata.view.url = \"${URL_VIEW}\" |
    .serviceMetadata.preview.url = \"${URL_PREVIEW}\"
    " "${PATH_YAML_RAW}" >> "${PATH_YAML}"
}
#+end_src
*** Deploy
# TODO
Once =services.yaml= has been created scp the raw and expanded configs
to the target host.
# ((((
#+name: *vars-deploy-services
#+begin_src bash :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --config)       local CONFIG="${2}"; shift; shift ;;
    --server)       local SERVER="${2}"; shift; shift ;;
    --path-runtime) local PATH_RUNTIME="${2}"; shift; shift ;;
    *)              POSITIONAL+=("$1"); shift ;;
esac
done

if [ -z $CONFIG ]; then
    echo '--config' is required
    return 1
fi

# : ${CONFIG:=}
: ${SERVER:=localhost}
: ${PATH_RUNTIME:=<<path-runtime()>>}

YAML=$(basename "${CONFIG}")
if [ ! -f "${CONFIG}" ]; then
    echo ${CONFIG} path does not exist.
    echo Did you actually build the config?
    echo Not deploying.
    return 1
fi
YAML_RAW=$(head -n 1 "${CONFIG}" | cut -b3-)
CONFIG_RAW="$(dirname ${CONFIG})/${YAML_RAW}"
EXISTING="${PATH_RUNTIME}/${YAML}"

scigraph_host="${SERVER}-deploy"  # by convention
scigraph_host_admin=${SERVER}
if [ ${SERVER} = localhost ]; then
    local TARGET="${PATH_RUNTIME}"
else
    local TARGET="${scigraph_host}:${PATH_RUNTIME}"
fi
#+end_src

# this block's quoting is funky because bash doesn't have anything like unquote
#+name: *deploy-services-backup-config
#+begin_src bash
E_YAML_RAW=$(head -n 1 "'${EXISTING}'" | grep "^#" | cut -b2-)  # on remote
if [ -n "${E_YAML_RAW}" ]; then
    YAML_BACKUP="'${PATH_RUNTIME}'/${E_YAML_RAW//.raw/}"
else
    mod_dt=$(stat -c %y "'${EXISTING}'" | cut -d "." -f1 | sed "s/[-\:]//g" | sed "s/\ /T/")  # on remote
    YAML_BACKUP="'${PATH_RUNTIME}/${YAML}'-${mod_dt}"
fi
echo cp -a "'${EXISTING}'" "${YAML_BACKUP}"
#+end_src

#+name: deploy-services
#+header: :comments noweb
#+begin_src bash :noweb yes :tangle ./bin/scigraph-functions.sh
function deploy-services () {
    # NOTE it is on YOU to make sure you are deploying the right config
    # to the right server, under normal circumstances you should
    # be running a run-build-deploy-services-* command
    <<*vars-deploy-services>>
    echo Will deploy services config to $TARGET
    echo $CONFIG_RAW
    echo $CONFIG
    <<*are-you-sure>>
    CMD='
        <<*deploy-services-backup-config>>'
    if [ ${SERVER} = localhost ]; then
        echo $CONFIG_RAW $TARGET
        echo ${CMD}
        echo cp "${CONFIG_RAW}" "${TARGET}"
        echo cp "${CONFIG}" "${TARGET}"
    else
        echo "${CMD}"
        ssh ${scigraph_host} "${CMD}"
        echo scp "${CONFIG_RAW}" "${TARGET}"  # if only we could rsync
        echo scp "${CONFIG}" "${TARGET}"
        echo ssh ${scigraph_host_admin} "sudo systemctl start scigraph"
    fi
}
#+end_src

#+NAME: test-scigraph-host
#+header: :results none
#+begin_src bash :var SERVER="localhost" :var PORT=9000
ontutils scigraph-stress --scigraph-api http://${SERVER}:${PORT}/scigraph
#+end_src
**** Gentoo
# TODO ob-async ?
#+NAME: restart-services-gentoo
#+header: :async t
#+begin_src bash :dir /ssh:hostname|su:root@hostname:
/etc/init.d/scigraph-services restart
#+end_src

#+CALL: restart-services-gentoo() :dir /su:root@localhost: :eval never
#+CALL: test-scigraph-host() :var SERVER="localhost" :eval never
**** Amazon Linux 2
#+NAME: restart-services-aws
#+header: :async t
#+begin_src bash :dir /ssh:hostname|sudo:hostname:
systemctl restart scigraph
journalctl -u scigraph.service -f | head -n 60
#+end_src

# #+CALL: restart-services-aws() :dir (:dir-tramp-sudo "aws-scigraph") :eval never
# #+CALL: test-scigraph-host() :var SERVER="scigraph.scicrunch.io" :eval never
* Deployments
** nifstd
*** graph
**** load
Set =path-build-nifstd= here
#+name: path-build-nifstd
: /tmp/scigraph-build/nifstd

#+name: path-ontologies-nifstd
: ~/git/pyontutils/nifstd/scigraph/ontologies-nifstd.yaml

#+name: git-ref-nifstd
: master

#+name: run-load-graph-nifstd
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-nifstd
<<*source-scigraph-functions>>
load-graph-ontload \
--path-build <<path-build-nifstd()>> \
--folder-name-graph <<folder-name-graph()>> \
--path-ontologies <<path-ontologies-nifstd()>> \
--git-ref <<git-ref-nifstd()>>
#+end_src
**** deploy
**** deploy from CI
*** services config
**** build
#+name: cypher-resources-nifstd
: ~/git/pyontutils/nifstd/scigraph/cypher-resources.yaml

#+name: run-build-services-nifstd
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-nifstd
<<*source-scigraph-functions>>
build-services \
--path-build <<path-build-nifstd()>> \
--path-cypher-resources <<cypher-resources-nifstd()>>
#+end_src
**** deploy
** sparc
*** data
interlex build
*** graph
**** load
Set =path-build-sparc= here
#+name: path-build-sparc
: /tmp/scigraph-build/sparc

Set =path-ontologies-sparc= here
#+name: path-ontologies-sparc
: ~/git/sparc-curation/resources/scigraph/ontologies-sparc.yaml

#+name: git-ref-sparc
: dev

#+name: run-load-graph-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-sparc
<<*source-scigraph-functions>>
load-graph-ontload \
--path-build <<path-build-sparc()>> \
--folder-name-graph <<folder-name-graph()>> \
--path-ontologies <<path-ontologies-sparc()>> \
--git-ref <<git-ref-sparc()>>
#+end_src
**** deploy
#+name: run-deploy-graph-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc
<<*source-scigraph-functions>>
deploy-graph \
--server aws-scigraph \
--path-build <<path-build-sparc()>>
#+end_src
**** deploy from CI
*** services config
**** build
#+name: cypher-resources-sparc
: ~/git/sparc-curation/resources/scigraph/cypher-resources.yaml

#+name: host-services-sparc
: scigraph.scicrunch.io

#+name: run-build-services-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc
<<*source-scigraph-functions>>
build-services \
--path-build <<path-build-sparc()>> \
--svc-host <<host-services-sparc()>> \
--path-cypher-resources <<cypher-resources-sparc()>>
#+end_src
**** deploy
[[file:/ssh:aws-scigraph-deploy:services.yaml]]
#+name: run-deploy-services-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc
<<*source-scigraph-functions>>
deploy-services \
--config <<path-build-sparc()>>/<<file-stem-services-output()>>.yaml \
--server aws-scigraph
#+end_src
** sparc-data
*** data
apinatomy build
*** graph
**** load
Set =path-build-sparc-data= here
#+NAME: path-build-sparc-data
: /tmp/scigraph-build/sparc-data

Set =folder-name-graph-sparc-data= here
#+name: folder-name-graph-sparc-data
: sparc-data

=path-ontologies-sparc-data=
#+name: path-ontologies-sparc-data
: ~/git/sparc-curation/resources/scigraph/ontologies-sparc-data.yaml

#+name: run-load-graph-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-sparc-data
<<*source-scigraph-functions>>
load-graph \
--path-build <<path-build-sparc-data()>> \
--folder-name-graph <<folder-name-graph-sparc-data()>> \
--path-ontologies <<path-ontologies-sparc-data()>>
#+end_src

**** deploy
#+name: run-deploy-graph-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc-data
<<*source-scigraph-functions>>
deploy-graph \
--server aws-scigraph-data \
--path-build <<path-build-sparc-data()>>
#+end_src
*** services config
[[file:/ssh:aws-scigraph-data-deploy:services.yaml]]
**** build
#+name: cypher-resources-sparc-data
: ~/git/sparc-curation/resources/scigraph/cypher-resources.yaml

#+name: host-services-sparc-data
: sparc-data.scicrunch.io

#+name: run-build-services-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc-data
<<*source-scigraph-functions>>
build-services \
--path-build <<path-build-sparc-data()>> \
--svc-host <<host-services-sparc-data()>> \
--path-cypher-resources <<cypher-resources-sparc-data()>>
#+end_src
**** deploy
#+name: run-deploy-services-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-data
<<*source-scigraph-functions>>
deploy-services \
--config <<path-build-sparc-data()>>/<<file-stem-services-output()>>.yaml \
--server aws-scigraph-data
#+end_src
**** build-deploy
** dev local ontology
*** graph
**** deploy
#+begin_src bash :noweb yes
./bin/deploy-graph --path-build
#+end_src
*** services config
**** build
**** deploy
#+name: run-deploy-services-sparc-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-local
<<*source-scigraph-functions>>
deploy-services --config <<path-build-sparc()>>/<<file-stem-services-output()>>.yaml
#+end_src
**** build-deploy
** dev local sparc-data
*** graph
**** deploy
#+name: folder-name-runtime-sparc-data-local
: sparc-data

#+name: run-deploy-graph-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc-data-local
<<*source-scigraph-functions>>
deploy-graph \
--path-build <<path-build-sparc-data()>> \
--folder-name-runtime <<folder-name-runtime-sparc-data-local()>>
#+end_src
*** services config
**** build
#+name: file-stem-sparc-data-local
: services-sparc

#+name: run-build-services-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc-data-local
<<*source-scigraph-functions>>
./build-services \
--path-build <<path-build-sparc-data()>> \
--path-cypher-resources <<cypher-resources-sparc-data()>> \
--file-stem <<file-stem-sparc-data-local()>> \
--folder-name-runtime <<folder-name-runtime-sparc-data-local()>>
#+end_src
**** deploy
#+name: run-deploy-services-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-data-local
<<*source-scigraph-functions>>
deploy-services --config <<path-build-sparc-data()>>/<<file-stem-sparc-data-local()>>.yaml
#+end_src
**** build-deploy
* Per operating system
:properties:
:visibility: folded
:end:
** Gentoo
*** Setup
**** Build host
#+include: "./README.org::#Setup:Build host:Gentoo" :only-contents t
**** Services host
#+include: "./README.org::#Setup:Services host:Gentoo" :only-contents t
*** Code
**** Build
**** Deploy
*** Graph
**** Build
**** Deploy
*** Config
**** Build
**** Deploy
** Ubuntu
*** Setup
**** Build host
#+include: "./README.org::#Setup:Build host:Ubuntu" :only-contents t
# **** Services host
# #+include: "./README.org::#Setup:Services host:Ubuntu" :only-contents t
** AWS Linux 2
*** Setup
**** Services host
#+include: "./README.org::#Setup:Services host:AWS Linux 2" :only-contents t
